2. 알아두어야 할 자바스크립트: ES2015+ 문법
    ES - ECMAScript
    ES2015 == ES6

    2.1 ES2015+
    2015년 발표 자바스크립트 표준 문법안: 상당한 변화
    2016년 승인 후 ES6이 되었다.

    babel: 구형 브라우저에서 ES6 돌아가게 해주는 도구
    
    2.1.1 const, let
    * var: 변수 선언(이전 버전)
    ---> const, let으로 대체

    * var의 단점: Hoisting 호이스팅.
        변수의 선언이 아무곳에서나 이뤄져서 소스코드 이해도가 떨어짐
        함수 스코프(=영역)
        함수 내 변수를 선언하면 어디서든 사용할 수 있었다.

    * const, let: 블록 스코프
    ??{ (??에 따라 함수 블록, if문 블록, for분 블록 등으로 불림)
        // 중괄호와 중괄호 사이가 block
        // 블록에서 선언되면 블록 내에서만 존재한다.
    }

    // 예시
    // var x; 호이스팅 되어 맨위로 올라 온 것 처럼 보인다.
    if(true){
        var x = 3; // 전연스코프 혹은 함수스코프
    }
    console.log(x);
    VM255:4 3

    if(true){
        let y = 5; // 블록 스코프 block scope
    }
    console.log(y);
    VM359:4 Uncaught ReferenceError: y is not defined
        at <anonymous>:4:13



    let a = 3; // 변수 선언
    a = 5;
    const b = 4; // 상수를 의미한다, 한번 초기화 하면 변경할 수 없음.
    b = 6; //그리고 상수는 반드시 처음 선언시 반드시 초기화 해야한다.
    VM435:4 Uncaught TypeError: Assignment to constant variable.
        at <anonymous>:4:3
    (anonymous) @ VM435:4

    대부분 const getSum = function(a, b){
        return a+b;
    }//질문 있음

    2.1.2 템플릿 문자열
    * 문자열 표현
    1) ''
    2) ""
    3) ``: 백틱, esc 밑에 있는 ~키와 같은 자리를 차지
            템플릿 문자열로 문자열 내부에서 변수 사용이 가능

    let n1 = 1;
    let n2 = 2;
    let res = 3;
    let str1 = n1+'더하기'+n2+'는 \''+res+'\'';
    console.log(str1);
    let str2 = `${n1}더하기 ${n2}는 '${res}'`;
    console.log(str2);

    2.1.3 객체 리터럴
    * literal: 구체적인 값
        1,  123, "김영진" 하나는 숫자 1, 한자는 문자열 김영진의 구체적인 값을 말한다.
    * object literal: 객체 리터럴은 해당 객체의 타입? 생성된 객체, 실행 도중에 객체의 속성, 메소드를 동적으로 추가 가능하다.
        - 이전 버전
            var sayNode = function(){ // 한쪽으로 값을 입력하기 때문에 대입문이라 한다.
                console.log(`node`);
            };
            var es = `ES`;
            var oldObject = { // 객체 리터럴 선언, 사용 초기화
                sayJS: function(){ // key:value
                    console.log(`야호!`);
                },
                sayNode:sayNode,
            }; // oldObject.sayNode(), oldObject.sayJS();를 사용 할 수 있게된다.
            oldObject[es+6] = 'Fantastic';
            oldObject.ES6 = 'Fantastic';
            oldObject.sayJS();
            oldObject.sayNode();
            console.log(oldObject.ES6);


        - 최신 버전: 속성명에 변수 가능
            // old를 실습하지 않앗다면 const sayNode=function(){...}으로 써야 함
            // const sayNode = function(){ // 한쪽으로 값을 입력하기 때문에 대입문이라 한다.
            //     console.log(`node`);
            // };
            // const es = 'ES';
            const newObject = {
                sayJS(){// function 생략 가능
                    console.log(`nodeㅁㄴㅇㄹ`);
                },
                sayNode, // sayNode:sayNode라고 이전버전에 한다면... 최신버전엔 key value가 같은 spell이면 한번만 적는다.
                [es+7]:'환톼스튁',
            };
            newObject.sayNode();
            newObject.sayJS();
            console.log(newObject.ES7);

            - {name:name, age:age} ==> {name, age};

    2.1.4 화살표 함수 arrow function
    - 기존: function을 이용해서 함수 정의
    - 현재

    -old
    function add(x,y){
        return x+y;
    }

    -new
    const add2 = (x,y) =>{return x+y;};
    const add3 = (x,y) => x+y;// 함수 내의 명령이 하나며 리턴문일 때
    const add3 = (x,y) => (x+y); // 이것이 계산되어 리턴이 된다.

    function not1(x){ return !x;};
    --->
    const not2 = (x)=>(!x);

    * old와 new의 차이점: this의 바인드 방식의 차이(bind);
        console과 어쩌구가 언제 bind 되는가?
    - old는 old의 객체내부의 함수에서 this를 바로 접근 못한다.
        그래서 변수를 하나 선언 후 할당하여 사용

    - new에서의 this는 자신의 객체를 의미

    - forEach: 나열가능한객체(iterable)에 들어있는 (값을 하나씩 불러와 해당 literal에 삽입해 변수로 반환)
        원소 각각에 대해 매개변수인 콜백함수를 호출함

    const relationship2 = {
        name: 'zero',
        friends: ['zero',`hero`,`xero`],
        logFriend(){
            this.friends.forEach(friend => {
                console.log(this.name, friend);
            })
        }
    };
    relationship2.logFriend();

    2.1.5 구조분해할당
    - old객체, 배열로부터 속성 도는 요소 접근
    객체명. 속성명 ---> 객체명[속성명]
    배열명[인덱스]

    const a = oldObject;
    = =(대입 또는 할당 연산자)의 왼쪽에는 리터럴, 수식 사용 불가능

    * 객체의 속성명(키- 콜론 왼쪽)과 할당받을 변수를 같게
        구조를 분해해서 값을 가져와 대입해준다.
    const candyMachine = {
        status:{
            name: 'node',
            count: 5,
        },
        getCandy(){
            this.status.count--;
            return this.status.count;
        }
    }
    
    const {getCandy, status:{count}} = candyMachine;
    // candyMachine의 status:count값을 getCandy 실행시켜서 할당시킴
    
    2.1.6 Class: 클래스 문법은 ES6에서 새로 도입됨
    - 자바스크립트를 학술적으로는 객체지향 언어라고 하지 않음
    - 객체중심언어, 프로토타입기반 언어(prototype based language)
    Classless language, Instance based language
    - 프로토타입: 원형 - 객체를 사용하는데, 객체의 원형만 가지고 있고
    실행 도중에 속성, 메소드를 추가 또는 삭제가 가능한 형태로 되어있었다
    - 상속, 다형성 구현이 가능하나 매우 어려움
    const add1 = (a,b)=> return 5;

    * 프로토타입 상속 예제 코드
    var Human = function (type){ //function-Function 객체
        this.type = type||'human';
        console.log('b');
    }; // this를 사용함으로 Human 클래스명이자 생성자 담당
    Human.isHuman = function(human){
        return human instanceof Human;// 앞놈이 뒷놈의 객체인가? 하는 연산자
    };
    Human.prototype.breathe = function(){
        alert(`h-a-a-m`);
        console.log(`알겠습니다`);
    }; // 클래스 메소드 구현
    // Human이라는 객체 구현
    
    var Zero = function(type, firstName, lastName){
        Human.apply(this, arguments);// super();
        this.firstName = firstName;
        this.lastName = lastName;
    }; // Zero라고 하는 객체가 Human 객체를 상속한 것으로 연결

    Zero.prototype = Object.create(Human.prototype); // 원형 복사
    Zero.prototype.constructor = Zero; // 상속

    Zero.prototype.sayName = function(){
        // alert(this.firstName+', '+this.lastName);
        alert(`${this.firstName} ${this.lastName}`);
    }; //자식객체의 메소드 구현

    var oldZero =  new Zero('human','YeungJin','akakr');
    Human.isHuman(oldZero);

    console.log();

    * 클래스 문법 도입: 새로운 코드

    class Human {
        constructor(type = 'human'){
            // 생성자, 매개변수 1개, human을 디폴트 값으로 설정함
            // 다형성을 위해 여러개 선언 할 필요가 없다.
            this.type = type; // 속성을 정의 this를 사용
        };
        static isHuman(human){
        return human instanceof Human;
        };
        breathe(){
         alert('아아악')   ;
        };
    };
    class Zero extends Human{ // extends 로 상송관계 정의
        constructor(type, firstName, lastName){
            super(type);
            this.firstName = firstName;
            this.lastName = lastName;
        };
        sayName(){
            super.breathe();
            alert(`${this.firstName} ${this.lastName}`);
        };
    };
    
    const newZero = new Zero('human','배고파','살려줘');
    Human.isHuman(newZero);

    2.1.7 프로미스: Promise'
        비동기: 시간 많이 걸리는 이거 실행되도록 던져두고 데이터 올 때 까지 기다렸다가
                나는 다른 작업을 실행
    - 프로미스 이전의 비동기: 콜백처리
    // 콜백: 내가 다 끝내면 네가 실행해라
    ES6부터는 프로미스 사용 권장
    - 반드시 알아야 할 객체
    - 비동기 처리에서 성공, 실패의 경우를 나눠서 구현
    - 프로미스 사용 이유 또는 문법 개발 배경
        콜백 지옥(callback hell)현상 극복을 위해
    - 프로미스 사용 규칙
        1) 프로미스 객체 생성
            객체 생성시의 매개변수: resolve(), reject()를 매개변수로 가진 콜백함수(화살표)
        2) 생성된 객체에 then(), catch(), finally() 메소드 호출
            세개의 메소드의 매개변수: 콜백함수
            resolve()호출---> than() 실행
            reject()호출---> catch() 실행
            호출하건 안하건---> finally()
    // 내가 언젠가 끝내니까 뭔가 하고 있으면 값을 리턴해줄게
    const num = Math.random();
    const condition = num<0.5?true:false; // 값에 따라 resolve, reject
    const promise = new Promise((resolve, reject)=>{
        if(condition){
            resolve('성공');
        }else{
            reject('실패');
        }
    });
    //blah
    console.log(num);
    promise // promise에 then catch finally 생성
        .then((message)=>{
            console.log(message);
        })
        .catch((error)=>{
            console.error(error);
        })
        .finally(()=>{
            console.log('무조건');
        });

    * 추가 코드

    프로미스: 내용은 실행됐지만 결과가 아직 반환되지 않아 결과를 반환하려고 하는 객체
        then을 붙여 결과를 반환
        resolve(성공리턴값)->then으로 연결
        reject(실패리턴값)->catch로 연결
        finally 부분은 무조건 실행

    const condition = 10?true:false; // 값에 따라 resolve, reject
    const promise = new Promise((resolve, reject)=>{
        if(condition){
            resolve('성공');
        }else{
            reject('성공');
        }
    });
    //blah
    promise // promise에 then catch finally 생성
        .then((message)=>{
            return new Promise((resolve, reject)=>{
                resolve(message+'1');
            });
            console.log(message);
        })
        .then((message)=>{
            return new Promise((resolve, reject)=>{
                resolve(message+'2');
            });
            console.log(message);
        })
        .then((message)=>{
            return new Promise((resolve, reject)=>{
                resolve(message+'3');
            });
            console.log(message);
        })//메소드 체이닝

        프로미스 체이닝
        프로미스의 then안에 return값이 프로미스를 만들어 resolve를 할 경우
        자신의 다음 프로미스 then값을 사용하게 되고 하게되고...


        - 콜백
        function findAndSaveUser(Users){
            Users.findOne({},(err,user)=>{
                if(err){
                    return console.error(err);
                };
            });
            user.name='zero';
            user.save((err)=>{
                if(err){
                    return console.error(err);
                }
                Users.findOne({gender:'m'},(err,user)=>{
                    ///
                });
            });
        };

        - 프로미스
        function findAndSaveUser(Users){
            Users.findOne({})//findOne() - 프로미스객체 리턴
                .then((user)=>{
                    user.name = 'zero';
                    return user.save(); // save() - 프로미스객체 리턴
                })
                .then((user)=>{
                    return Users.findOne({gender:'m'});
                })
                .then((user)=>{
                    ///
                })
                .catch(err=>{
                    console.log(err);
                });
        };
        하나로 실행되지만 다 콜백으로 리턴하고 있다.

        * 여러개의 프로미스 한꺼번에 실행하기
        :Promise.all()//객체이름.all();
        const promise1 = Promise.resolve('성공1');
        const promise2 = Promise.resolve('성공2');
        // Promise.resolve(), Promise.reject();
        // 즉시 resolve하는 프로미스 객체 생성
        // 즉시 reject하는 프로미스 객체 생성
        //promise1.then().catch().finally();
        Promise.all([promise1,promise2])//둘 다 resolve되어야 then을 실행할 수 있다.
            .then((res)=>{
                console.log(res);//['성공1','성공2']
            })
            .catch((err)=>{
                console.log(err);
            });
        promise 객체를 만들고 then을 배출한다를 할 수 있어야 만들 수 있다

    2.1.8 async/await: ES2017부터, Node 7.6부터 지원
    - ES6+/ES2015+
    - 프로미스가 콜백헬을 극복하고 있지만, 코드의 장황성은
        개선되지 못함
        function findAndSaveUser(Users){
            Users.findOne({})//findOne()
                .then((user)=>{
                    user.name = 'zero';
                    return user.save();
                })
                .then((user)=>{
                    return Users.findOne({gender:'m'});
                })
                .then((user)=>{
                    ///
                })
                .catch(err=>{
                    console.log(err);
                });
        };
        1) function을 async function으로 변경
        2) 프로미스 객체 반환 함수들에 호출을
            변수 = await 함수명();의 형식으로 바꾼다
        async function findAndSaveUser(Users){
            try{
                let user = await Users.findOne({});
                user.name = 'zero';
                user = await user.save();
                user = await Users.findOne({gender:'m'});
                ///
            }catch(error){
                console.log(error);
            }
        }

        함수이기 때문에 화살표 함수로 쓸 수 있다
        const findAndSaveUser = async(Users)=>{
            try{
                let user = await Users.findOne({});
                user.name = 'zero';
                user = await user.save();
                user = await Users.findOne({gender:'m'});
                ///
            }catch(error){
                console.log(error);
            }
        }

        * async 함수는 항상 Promise 객체를 반환한다
        async function findAndSaveUser(Users){
            return new Promise({...});
            //언젠가인지 모르겠으나 return값이 있을것이다.
        }
        findAndSaveUser().then(()=>{

        });
        //이런식으로 콜백이나 then을 붙이는 코딩이 가능하다
        async function other(){
            const res = await findAndSaveUser();
        }//이렇게 다른 function에서 부를 수 있다.
        //서버쪽 java script...

        //js = java script

    2.2 Front-End js
        : html내의 script 태그안에 작성되어 실행되는 JS 코드
        DOM, BOM, aJax
        Document Object Model: html소스코드를 객체로 만들어 
                                Document객체로 관리
                - element: 태그를 객체로 만들어 이 이름을 붙임, html, head, body 등이 있음, node(노드)라고 불리기도 함(nodeJS랑 다름)
                - attribute: 시작태그에 있는 속성
                    a태그의 href
                - getElementById
                - getElementsByTagName
                - getElementsByClassName
                - querySelector, querySelectorAll
        Browser Object Model: window객체, Document객체, etc...
            history객체,...
            location.href='주소'
            redirection 기능 구현시 사용
        2.2.1 - aJax(Asynchronous Javascript And XML=비동기 자바스크립트와 XML)
            웬페이지 전환없이 새로운 데이터를 불러와서
            화면에 변화를 부분적으로 하게 하는 기능
        - Web 2.0 시도 도래
        - MashUp, OpenAPI라는 기능을 구현 할 수 있도록 함
            다른 회사의 OpenAPI를 가져와서 MashUp하여 보여주고 있다.
            이 행위를 aJax라고 한다.

        - aJax 요청 응답 라이브러리
            1) XMLHttpRequest 객체: 표준
            그래서 나온게 fetch
            $.ajax()===> jQuery
            axios(): 프로미스, async/await 잘 지원
            
            ajax matome
            air-h.jp/article
            
        front.html 사용예제
        - axios.get(): get 요청 대응하는 aJax 기능 호출 메소드
            반환값: promiss 객체
        - axios.post(): post 요청 처리, 반환값은 promis객체

        - axios  p.83에서 예제코드는 실행시 에러 발생
            이유는 CORS에러 -p.482 참고

        2.2.2 FormatData
        form 태그와 관련되어있다.
        동적으로 관리가 가능
        
        2.2.3 encodeURIComponent(), decodeURIComponent()
        - url주소에서 한글처리하기 위한 메소드
        - BOM 중에 window객체의 메소드
            window객체는 BOM객체의 최상위 객체
            대표적으로 alert(), confirm(), open() 같은 것들이 있다.
            원래는 window.alert(), window.confirm(), window.open()로 써야하지만 생략 할 수 있다.

        2.2.4 데이터 attribute와 dataset
        * HTML5에서 태그에 사용자 정의 속성을 사용할 있음?
            data-+사용자 정의 속성명을 넣으면 된다.
            data-id
            data-user-job
            사용자 별로 다르게 무언가를 부여할 때 사용한다
            dataset으로 접근/사용할 때
            키값은 data-를 떼어낸 단어를 사용하는데, data-다음의 합성어(user-job)일때는 userJob이 된다
                                            단어1-단어2-단어3...이라면 단어 1제외 모든 단어의 첫글자를 대문자로 만든다
                                            사용자 속성을 대문자>앞글자-로 바꾼다.
                                            querySelector에 dataset.데이터 값=값;을 넣어주면 해당 html 태그에 attribute가 추가적으로 들어간다.
         
         