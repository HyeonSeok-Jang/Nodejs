4. http 모듈로 서버 만들기
  4.1 요청과 응답 이해하기
    * server vs. clearInterval 
      서비스 제공(웹 서버) vs. 클라이언트(웹 브라우저)
    * request vs. response
    - 클라이언트에서 Server로 리퀘스트를 보낸다
    - 서버는 리퀘스트 정보를 확인 후 처리
    - Server는 처리 결과를 client에 reposne해야 함

    이벤트 처리와 유사
    이벤트가 서버로 오면 미리 정해 둔 이벤트 리스너(CALL, back)을 처리하고 그 결과를 클라이언트로 응답
    
    * 노드에서 HTTP서버를 만들기 위해
        ~를 사용한다

    사용하는 통신규약(프로토콜)

    * HTTP: Request 와 Response를 위해
    Hyper Txt Transfer Protocol
    HTTP의 메세지를 주고 받음
    HTTP Headers와 boy로 구성
    Http Message 종류:
    HTTP 요청 메세지
      header+ body(사용자 입력값)
    HTTP 응답 메세지
      header+ body(html1문서)
    이래놓고 거꾸로 사용

    - localhost: 현재 컴퓨터의 내부 도메인 주소
      127.0.0.1: 현재 컴퓨터의 내부 IP주소
    - 포트번호
    0~1024 포트번호는 시스템 예약 포트번호
    80: 웹서버포트
    21: FTP서버포트
    23: TELNET서버포트
    포트는 하나만 열어두는게 좋다

    * html 파일을 읽어서 전송하기: fs모듈 사용

    * HTTP status code
    2XX: 성공, 200-성공, 201(작성됨)
    3XX: 리다이렉션, 301(영구이동), 302(임시이동), 304(수정되지 않음)
    4XX: 400-잘못된 요청, 401-권한 없음, 403-금지됨 forbidden, 404-notfound 찾지못함
    5XX: 서버오류, 500-서버 내부 오류, 502-불량게이트웨이, 503-서비스 사용불가

  4.2 REST와 라우팅 사용하기
  - REST : REpresentional State Transfer(대표적인 상태 전달)
    대표적인 상태 전달, 주소로 이루어짐

  - RESTful하게 서비스 개발 권장
    주소에 의미를 명확하게 전달하도록 주소 구성을 하자.

  - RESTful하게 개발 권장사항
    주소: 명사형으로 지정
    /user: 사용자 관련 서비스 요청 주소
    /post: 게시물 관련 서비스 요청 주소
    이런식으로 정리해놓은게 RESTful하게...

  * req는 사용저의 요청정보를 담는다
  - req.method: GET, POST, DELETE, PATCH, PUT, OPTIONS
  - req.url: 요청주소, /나 포트번호 뒤에 나오는 것을 받아 낼 수 있다.

  * res, 서버의 응답정보 객체

  1. GET / 요청


    CRUD(Create-Read-Update-Delete)의 표현은 어떻게 할 것인가?
      HTTP요청방법(Request Method)를 가지고 구분함.

    * HTTP Request Method: GET, POST, PUT, PATCH, DELETE를 실험 해 볼 수 있다.
    PostMan 찾아보고 사용법 익혀두면... 브라우저 없이 HTTP 요청 메소드를 테스트 해볼 수 있다.

    만일 GET /user라고 썼다면 클라이언트에 요청 어쩌구 가져온다.
    PATCH /user/1 1번 id를 가진 user의 정보를 수정
    DELETE /user/1 1번 id를 가진 user를 삭제

    * REST 주소구조로 개발한 서버
      RESTful하다
      RESTful 웹서버


    p.151/p.180
    나머지 클라이언트
    restfront.js //클라이언트
    about.html //클라이언트
    restserver.js //서버 프로그램

    서버에 파일이 있지만 그것을 웹서버 프로그램이 읽어서 클라이언트로 보내주고
    응답하면 그 결과를 브라우저가 읽어서 처리해서 보여줌

  4.3 쿠키와 세션 이해하기
  cookie, session
  쿠키 사용 이유: HTTP 특성 때문
  HTTP는 상태저장을 하지 않음: stateless Protocol
  사용자의 구별이 어려움: 로그인처리
  req
    - req.url
    - req.method
    - req.headers.cookie 요청 헤더의 쿠키 정보를 저장하고있는 객체
    쿠키: 키=값으로 된다
  * 쿠키 설정하기

  res.writeHead(응답코드,{'Set-Cookie':'키1=값1,키2=값2,...'})로 처리
  응답코드를 
    4.3.7
    * 쿠키명=쿠키값: 기본적 쿠키 값
    * Expires=날짜: 만료 기간
    * Max-age=초: Expires과 비슷하지만 초단위로 제어
    * Secure: HTTPS일 경우에만 쿠키 전송
    * HttpOnly: 설정 시 자바스크립트에서 쿠키 접근 할 수 없다.
      js(브라우저에서 실행되는)에서 쿠키 접근 불가능함
      브라우저에서 실행된 js: html내의 script태그 내의 js.

  쿠키의 단점: 클라이언트의 브라우저에 저장된다.--> 해킹 가능성이 높아짐
  이것으로 바로 쿠키 조작이 가능해짐
  이 방지책으로 세션이 나옴 하지만 세션은 쿠키 없이는 사용 불가능함
  세션은 서버의 정보를 저장함
  서버에서 Redis라고 하는 특이한 DB?를 활용함 거기서 세션처리가 많음
  
  세션: 중요한 정보는 서버에서 관리하고 클라이언트에는 세션의 키만 제공함, 이 키는 쿠키로 저장됨
  서버에서 세션 객체 생성 후 uniqueint(키)를  만들어 속성명으로 사용함
  
  실 서버에는 세션을 직접 구현하지 않도록
    6장의 express-session 사용하기
  
  4.4 HTTP
    https
      http+SSL암호화
      SSL은 네트워크 7계층 위의 단계
      우리는 TCP/IP사용
      https=7계층 application+SSL

    http2
      속도 개선을 위해 개발되었고 ssl암호화는 당연
      Sync가 다 붙어있는데 동기, 그 자리에서 다 끝나야 다음 작업을 함

  4.5 cluster
    싱글스레드인 노드가 CPU코어를 모두 사용하게...
    Redis 사용: 키를 저장해서 사용한다거나...
    컴퓨터 자원은 공유 못함
    
    서버 클러스터링. 워커 스레드랑 비슷함

    
    워커 프로세스를 다시 살린다는 것은 좋지않음
    하드의 내용이 메모리로 올라가기 때문에 서버 처리하는 속도가 늦어져 큰 속도가 저하가 일어남
    최대한 죽이지 않는 방식이 좋다.